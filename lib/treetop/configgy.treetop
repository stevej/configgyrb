grammar Configgy
  rule root
    root_bits:root_bit* whitespace* {
      def apply(attr)
        root_bits.elements.each { |node| node.apply(attr) }
      end
    }
  end

  rule root_bit
    whitespace* assignment {
      def apply(attr)
        assignment.apply(attr)
      end
    } / whitespace* toggle {
      def apply(attr)
        toggle.apply(attr)
      end
    }
  end

  rule assignment
    identifier whitespace* op:("=" / "?=") whitespace* value {
      def apply(attr)
        key = identifier.text_value
        if (op.text_value == "=") or !attr.has_key?(key)
          attr[key] = value.to_value
        end
      end
    }
  end

  rule toggle
    identifier whitespace* true_false {
      def apply(attr)
        key = identifier.text_value
        attr[key] = true_false.to_value
      end
    }
  end

  rule value
    number / string / true_false / string_list
  end

  rule whitespace
    (" " / "\t" / "\n" / "#" [^\n]* "\n")
  end

  rule number
    "-"? [0-9]+ decimal:("." [0-9]+)? {
      def to_value
        decimal.text_value.empty? ? text_value.to_i : text_value.to_f
      end
    }
  end
  
  rule string
    "\"" raw:string_innards* "\"" {
      def to_value
        raw.elements.inject("") { |total, segment| total + segment.unquoted }
      end
    }
  end

  rule string_innards
    [^\\\"]+ {
      def unquoted
        text_value
      end
    } / "\\" quoted_entity {
      def unquoted
        quoted_entity.unquoted
      end
    }
  end

  rule quoted_entity
    [^ux] {
      def unquoted
        case text_value
          when "r" then "\r"
          when "n" then "\n"
          when "t" then "\t"
          when "$" then "\\$"
          else text_value
        end
      end
    } / "u" digits:(hex_digit hex_digit hex_digit hex_digit) {
      def unquoted
        [ digits.text_value.to_i(16) ].pack("U")
      end
    } / "x" digits:(hex_digit hex_digit) {
      def unquoted
        digits.text_value.to_i(16).chr
      end
    }
  end

  rule hex_digit
    [0-9a-fA-F]
  end
  
  rule true_false
    "true" {
      def to_value
        true
      end
    } / "on" {
      def to_value
        true
      end
    } / "false" {
      def to_value
        false
      end
    } / "off" {
      def to_value
        false
      end
    }
  end
  
  rule string_list
    "[" whitespace* list:(item:(string / number) (whitespace* ",")? whitespace*)* "]" {
      def to_value
        list.elements.map { |e| e.item.to_value }
      end
    }
  end
  
  rule identifier
    identifier_token ("\." identifier_token)*
  end

  rule identifier_token
    ([a-zA-Z_] [-a-zA-Z_]*)
  end
end



# 
# val sections = new Stack[String]
# var prefix = ""
# val tagNameToken: Parser[String] = """[a-zA-Z][-\w]*""".r
# 



# def root = rep(includeFile | assignment | toggle | sectionOpen | sectionClose |
#                sectionOpenBrace | sectionCloseBrace)
# 
# def includeFile = "include" ~> string ^^ {
#   case filename: String =>
#     new ConfigParser(attr.makeAttributes(sections.mkString(".")), importer) parse importer.importFile(filename)
# }
# 
# 
# 
# def sectionOpen = "<" ~> tagNameToken ~ rep(tagAttribute) <~ ">" ^^ {
#   case name ~ attrList => openBlock(name, attrList)
# }
# def tagAttribute = opt(whiteSpace) ~> (tagNameToken <~ "=") ~ string ^^ { case k ~ v => (k, v) }
# def sectionClose = "</" ~> tagNameToken <~ ">" ^^ { name => closeBlock(Some(name)) }
# 
# def sectionOpenBrace = tagNameToken ~ opt("(" ~> rep(tagAttribute) <~ ")") <~ "{" ^^ {
#   case name ~ attrListOption => openBlock(name, attrListOption.getOrElse(Nil))
# }
# def sectionCloseBrace = "}" ^^ { x => closeBlock(None) }
# 
# private def openBlock(name: String, attrList: List[(String, String)]) = {
#   val parent = if (sections.size > 0) attr.makeAttributes(sections.mkString(".")) else attr
#   sections += name
#   prefix = sections.mkString("", ".", ".")
#   val newBlock = attr.makeAttributes(sections.mkString("."))
#   for ((k, v) <- attrList) k match {
#     case "inherit" => newBlock.inheritFrom = Some(if (parent.getConfigMap(v).isDefined) parent.makeAttributes(v) else attr.makeAttributes(v))
#     case _ => throw new ParseException("Unknown block modifier")
#   }
# }
# 
# private def closeBlock(name: Option[String]) = {
#   if (sections.isEmpty) {
#     failure("dangling close tag")
#   } else {
#     val last = sections.pop
#     if (name.isDefined && last != name.get) {
#       failure("got closing tag for " + name.get + ", expected " + last)
#     } else {
#       prefix = if (sections.isEmpty) "" else sections.mkString("", ".", ".")
#     }
#   }
# }
