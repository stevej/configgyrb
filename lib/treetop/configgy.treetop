grammar Treetop_Configgy
  rule root
    d:declaration* whitespace* {
      def apply(attr)
        d.elements.each { |node| node.apply(attr) }
      end
    }
  end

  rule declaration
    whitespace* d:(include_file / assignment / toggle / section) {
      def apply(attr)
        d.apply(attr)
      end
    }
  end

  rule assignment
    identifier whitespace* op:("=" / "?=") whitespace* value {
      def apply(attr)
        key = identifier.text_value
        if (op.text_value == "=") or !attr.has_key?(key)
          attr[key] = value.to_value
        end
      end
    }
  end

  rule toggle
    identifier whitespace* true_false {
      def apply(attr)
        key = identifier.text_value
        attr[key] = true_false.to_value
      end
    }
  end

  rule value
    number / string / true_false / string_list
  end

  rule whitespace
    (" " / "\t" / "\n" / "#" [^\n]* "\n")
  end

  rule number
    "-"? [0-9]+ decimal:("." [0-9]+)? {
      def to_value
        decimal.text_value.empty? ? text_value.to_i : text_value.to_f
      end
    }
  end

  rule string
    "\"" raw:string_innards* "\"" {
      def to_value
        raw.elements.inject("") { |total, segment| total + segment.unquoted }
      end
    }
  end

  rule string_innards
    [^\\\"]+ {
      def unquoted
        text_value
      end
    } / "\\" quoted_entity {
      def unquoted
        quoted_entity.unquoted
      end
    }
  end

  rule quoted_entity
    [^ux] {
      def unquoted
        case text_value
          when "r" then "\r"
          when "n" then "\n"
          when "t" then "\t"
          when "$" then "\\$"
          else text_value
        end
      end
    } / "u" digits:(hex_digit hex_digit hex_digit hex_digit) {
      def unquoted
        [ digits.text_value.to_i(16) ].pack("U")
      end
    } / "x" digits:(hex_digit hex_digit) {
      def unquoted
        digits.text_value.to_i(16).chr
      end
    }
  end

  rule hex_digit
    [0-9a-fA-F]
  end

  rule true_false
    "true" {
      def to_value
        true
      end
    } / "on" {
      def to_value
        true
      end
    } / "false" {
      def to_value
        false
      end
    } / "off" {
      def to_value
        false
      end
    }
  end

  rule string_list
    "[" whitespace* list:(item:(string / number) (whitespace* ",")? whitespace*)* "]" {
      def to_value
        list.elements.map { |e| e.item.to_value }
      end
    }
  end

  rule identifier
    identifier_token ("\." identifier_token)*
  end

  rule identifier_token
    ([a-zA-Z] [-a-zA-Z_]*)
  end

  rule section
    identifier_token whitespace* ("(" whitespace* (tag_attribute whitespace*)* ")")? whitespace* "{" root "}" {
      def apply(attr)
        new_name = identifier_token.text_value
        nested_attr = Configgy::ConfigMap.new(attr.root, attr.name == "" ? new_name : attr.name + "." + new_name)
        # FIXME attributes
        attr[new_name] = nested_attr
        root.apply(nested_attr)
      end
    }
  end

  rule tag_attribute
    name:"inherit" "=" value:string
  end

  rule include_file
    "include" whitespace* string {
      def apply(attr)
        load(string.text_value, attr)
      end
    }
  end
end
